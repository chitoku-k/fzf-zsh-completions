#!/usr/bin/env zunit

@setup {
    load ../src/git.zsh

    TEMP=$(mktemp -d)
    pushd $TEMP

    {
        git init

        mkdir directory1
        echo file1 > file1
        echo file2 > directory1/file2

        git add -A
        git commit -m '1st commit'
        git tag v1

        mkdir directory2
        echo ' file3 containing space ' > ' file3 containing space '
        echo $'file4\ncontaining\nnewlines' > directory2/$'file4\ncontaining\nnewlines'

        git checkout -b another-branch

        git add -A
        git commit -m ' 2nd commit'
        git tag v2

        git checkout master

        echo file1 >> file1
        echo file2 >> directory1/file2
    } &> /dev/null

    hash_1=$(git rev-parse --short v1)
    hash_2=$(git rev-parse --short v2)

    preview() {
        for opt in ${(Q)${(Z+n+)fzf_options}}; do
            if [[ $opt = --preview=* ]]; then
                eval ${${opt/--preview=/}/\{\}/${(q)@}} 2>&1
            fi
        done
    }
}

@teardown {
    rm -rf $TEMP
}

@test 'Testing completion: git **' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git '
    }

    prefix=
    _fzf_complete_git 'git '
}

@test 'Testing completion: git checkout **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git checkout '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git checkout '
}

@test 'Testing completion: git log **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git log '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git log '
}

@test 'Testing completion: git rebase **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git rebase '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git rebase '
}

@test 'Testing completion: git reset **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git reset '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git reset '
}

@test 'Testing completion: git branch **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index --multi'
        assert $2 same_as 'git branch -D '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git branch -D '
}

@test 'Testing completion: git cherry-pick **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index --multi'
        assert $2 same_as 'git cherry-pick '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git cherry-pick '
}

@test 'Testing completion: git merge **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index --multi'
        assert $2 same_as 'git merge '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git merge '
}

@test 'Testing completion: git commit --fixup=**' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)${prefix}another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)${prefix}master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)${prefix}v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)${prefix}v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)${prefix}$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=--fixup=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git commit --reedit-message=**' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)${prefix}another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)${prefix}master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)${prefix}v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)${prefix}v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)${prefix}$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=--reedit-message=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git commit --reuse-message=**' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)${prefix}another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)${prefix}master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)${prefix}v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)${prefix}v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)${prefix}$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=--reuse-message=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git commit --squash=**' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)${prefix}another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)${prefix}master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)${prefix}v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)${prefix}v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)${prefix}$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=--squash=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git commit -c **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit -c '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit -c '
}

@test 'Testing completion: git commit -qc **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit -qc '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit -qc '
}

@test 'Testing completion: git commit -C **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit -C '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit -C '
}

@test 'Testing completion: git commit -qC **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit -qC '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit -qC '
}

@test 'Testing completion: git commit --fixup **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit --fixup '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit --fixup '
}

@test 'Testing completion: git commit --reedit-message **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit --reedit-message '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit --reedit-message '
}

@test 'Testing completion: git commit --reuse-message **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit --reuse-message '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit --reuse-message '
}

@test 'Testing completion: git commit --squash **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit --squash '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit --squash '
}

@test 'Testing completion: git commit --message=**' {
    run git checkout another-branch

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit '

        run cat
        assert ${#lines} equals 2
        assert ${lines[1]} same_as "$(tput setaf 3)$hash_2 $(tput sgr0) ${prefix} 2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)$hash_1 $(tput sgr0) ${prefix}1st commit"
    }

    prefix=--message=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git commit -m **' {
    run git checkout another-branch

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit -m '

        run cat
        assert ${#lines} equals 2
        assert ${lines[1]} same_as "$(tput setaf 3)$hash_2 $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)$hash_1 $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit -m '
}

@test 'Testing completion: git commit -qm **' {
    run git checkout another-branch

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit -qm '

        run cat
        assert ${#lines} equals 2
        assert ${lines[1]} same_as "$(tput setaf 3)$hash_2 $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)$hash_1 $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit -qm '
}

@test 'Testing completion: git commit --message **' {
    run git checkout another-branch

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit --message '

        run cat
        assert ${#lines} equals 2
        assert ${lines[1]} same_as "$(tput setaf 3)$hash_2 $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)$hash_1 $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git commit --message '
}

@test 'Testing completion: git commit --author=**' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    prefix=--author=
    _fzf_complete_git 'git commit '

    assert $? equals 0
}

@test 'Testing completion: git commit --date=**' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    prefix=--date=
    _fzf_complete_git 'git commit '

    assert $? equals 0
}

@test 'Testing completion: git commit --author **' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    prefix=
    _fzf_complete_git 'git commit --author '

    assert $? equals 0
}

@test 'Testing completion: git commit --date **' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    prefix=
    _fzf_complete_git 'git commit --date '

    assert $? equals 0
}

@test 'Testing completion: git commit --file=**' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit --file='
    }

    prefix=--file=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git commit --template=**' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit --template='
    }

    prefix=--template=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git commit --pathspec-from-file=**' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit --pathspec-from-file='
    }

    prefix=--pathspec-from-file=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git commit -F **' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit -F '
    }

    prefix=
    _fzf_complete_git 'git commit -F '
}

@test 'Testing completion: git commit -qF **' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit -qF '
    }

    prefix=
    _fzf_complete_git 'git commit -qF '
}

@test 'Testing completion: git commit -t **' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit -t '
    }

    prefix=
    _fzf_complete_git 'git commit -t '
}

@test 'Testing completion: git commit -qt **' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit -qt '
    }

    prefix=
    _fzf_complete_git 'git commit -qt '
}

@test 'Testing completion: git commit --file **' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit --file '
    }

    prefix=
    _fzf_complete_git 'git commit --file '
}

@test 'Testing completion: git commit --template **' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit --template '
    }

    prefix=
    _fzf_complete_git 'git commit --template '
}

@test 'Testing completion: git commit --pathspec-from-file **' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit --pathspec-from-file '
    }

    prefix=
    _fzf_complete_git 'git commit --pathspec-from-file '
}

@test 'Testing completion: git commit --cleanup=**' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as --cleanup=strip
        assert ${lines[2]} same_as --cleanup=whitespace
        assert ${lines[3]} same_as --cleanup=verbatim
        assert ${lines[4]} same_as --cleanup=scissors
        assert ${lines[5]} same_as --cleanup=default
    }

    prefix=--cleanup=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git commit --cleanup **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit --cleanup '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as strip
        assert ${lines[2]} same_as whitespace
        assert ${lines[3]} same_as verbatim
        assert ${lines[4]} same_as scissors
        assert ${lines[5]} same_as default
    }

    prefix=
    _fzf_complete_git 'git commit --cleanup '
}

@test 'Testing completion: git commit --untracked-files=**' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit '

        run cat
        assert ${#lines} equals 3
        assert ${lines[1]} same_as --untracked-files=no
        assert ${lines[2]} same_as --untracked-files=normal
        assert ${lines[3]} same_as --untracked-files=all
    }

    prefix=--untracked-files=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git commit --untracked-files **' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit --untracked-files '

        run cat
        assert ${#lines} equals 3
        assert ${lines[1]} same_as no
        assert ${lines[2]} same_as normal
        assert ${lines[3]} same_as all
    }

    prefix=
    _fzf_complete_git 'git commit --untracked-files '
}

@test 'Testing completion: git commit **' {
    run git checkout another-branch
    echo >> ' file3 containing space '
    echo >> directory2/$'file4\ncontaining\nnewlines'
    echo >> ' file5 containing space '
    echo >> directory2/$'file6\ncontaining\nnewlines'

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --read0 --print0 --multi'
        assert $2 same_as 'git commit '

        run cat
        assert ${#lines} equals 5

        actual1=(${(0)lines[1]})
        assert ${#actual1} equals 3
        assert ${actual1[1]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0)  file3 containing space "
        assert ${actual1[2]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0) directory1/file2"
        assert ${actual1[3]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0) directory2/file4"

        actual2=(${(0)lines[2]})
        assert ${#actual2} equals 1
        assert ${actual2[1]} same_as 'containing'

        actual3=(${(0)lines[3]})
        assert ${#actual3} equals 4
        assert ${actual3[1]} same_as 'newlines'
        assert ${actual3[2]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0) file1"
        assert ${actual3[3]} same_as "$(tput setaf 1)?$(tput sgr0)$(tput setaf 1)?$(tput sgr0)  file5 containing space "
        assert ${actual3[4]} same_as "$(tput setaf 1)?$(tput sgr0)$(tput setaf 1)?$(tput sgr0) directory2/file6"

        actual4=(${(0)lines[4]})
        assert ${#actual4} equals 1
        assert ${actual4[1]} same_as 'containing'

        actual5=(${(0)lines[5]})
        assert ${#actual5} equals 1
        assert ${actual5[1]} same_as 'newlines'
    }

    prefix=
    _fzf_complete_git 'git commit '
}

@test 'Testing completion: git add **' {
    run git checkout another-branch
    echo >> ' file3 containing space '
    echo >> directory2/$'file4\ncontaining\nnewlines'
    echo >> ' file5 containing space '
    echo >> directory2/$'file6\ncontaining\nnewlines'

    _fzf_complete() {
        assert $# equals 2
        assert $1 matches '--ansi --read0 --print0 --multi '
        assert $2 same_as 'git add '

        run cat
        assert ${#lines} equals 5

        actual1=(${(0)lines[1]})
        assert ${#actual1} equals 3
        assert ${actual1[1]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0)  file3 containing space "
        assert ${actual1[2]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0) directory1/file2"
        assert ${actual1[3]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0) directory2/file4"

        actual2=(${(0)lines[2]})
        assert ${#actual2} equals 1
        assert ${actual2[1]} same_as 'containing'

        actual3=(${(0)lines[3]})
        assert ${#actual3} equals 4
        assert ${actual3[1]} same_as 'newlines'
        assert ${actual3[2]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0) file1"
        assert ${actual3[3]} same_as "$(tput setaf 1)?$(tput sgr0)$(tput setaf 1)?$(tput sgr0)  file5 containing space "
        assert ${actual3[4]} same_as "$(tput setaf 1)?$(tput sgr0)$(tput setaf 1)?$(tput sgr0) directory2/file6"

        actual4=(${(0)lines[4]})
        assert ${#actual4} equals 1
        assert ${actual4[1]} same_as 'containing'

        actual5=(${(0)lines[5]})
        assert ${#actual5} equals 1
        assert ${actual5[1]} same_as 'newlines'
    }

    prefix=
    _fzf_complete_git 'git add '
}

@test 'Testing completion (alias): git commit --squash **' {
    run git config alias.squash 'commit --squash'

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git squash '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git squash '
}

@test 'Testing completion (alias): git commit --amend --message **' {
    run git config alias.amend 'commit --amend --message'
    run git checkout another-branch

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git amend '

        run cat
        assert ${#lines} equals 2
        assert ${lines[1]} same_as "$(tput setaf 3)$hash_2 $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)$hash_1 $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git amend '
}

@test 'Testing completion (alias): git commit --date **' {
    run git config alias.commit-date 'commit --date'

    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    prefix=
    _fzf_complete_git 'git commit-date '

    assert $? equals 0
}

@test 'Testing completion (alias): git commit --pathspec-from-file **' {
    run git config alias.commit-spec 'commit --pathspec-from-file'

    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit-spec '
    }

    prefix=
    _fzf_complete_git 'git commit-spec '
}

@test 'Testing completion (alias): git commit --cleanup **' {
    run git config alias.commit-cleanup 'commit --cleanup'

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit-cleanup '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as strip
        assert ${lines[2]} same_as whitespace
        assert ${lines[3]} same_as verbatim
        assert ${lines[4]} same_as scissors
        assert ${lines[5]} same_as default
    }

    prefix=
    _fzf_complete_git 'git commit-cleanup '
}

@test 'Testing completion (alias): git commit --untracked-files **' {
    run git config alias.commit-untracked 'commit --untracked-files'

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit-untracked '

        run cat
        assert ${#lines} equals 3
        assert ${lines[1]} same_as no
        assert ${lines[2]} same_as normal
        assert ${lines[3]} same_as all
    }

    prefix=
    _fzf_complete_git 'git commit-untracked '
}

@test 'Testing completion (alias): git commit **' {
    run git checkout another-branch
    run git config alias.commit-all 'commit -a'

    echo >> ' file3 containing space '
    echo >> directory2/$'file4\ncontaining\nnewlines'
    echo >> ' file5 containing space '
    echo >> directory2/$'file6\ncontaining\nnewlines'

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --read0 --print0 --multi'
        assert $2 same_as 'git commit-all '

        run cat
        assert ${#lines} equals 5

        actual1=(${(0)lines[1]})
        assert ${#actual1} equals 3
        assert ${actual1[1]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0)  file3 containing space "
        assert ${actual1[2]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0) directory1/file2"
        assert ${actual1[3]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0) directory2/file4"

        actual2=(${(0)lines[2]})
        assert ${#actual2} equals 1
        assert ${actual2[1]} same_as 'containing'

        actual3=(${(0)lines[3]})
        assert ${#actual3} equals 4
        assert ${actual3[1]} same_as 'newlines'
        assert ${actual3[2]} same_as " $(tput sgr0)$(tput setaf 1)M$(tput sgr0) file1"
        assert ${actual3[3]} same_as "$(tput setaf 1)?$(tput sgr0)$(tput setaf 1)?$(tput sgr0)  file5 containing space "
        assert ${actual3[4]} same_as "$(tput setaf 1)?$(tput sgr0)$(tput setaf 1)?$(tput sgr0) directory2/file6"

        actual4=(${(0)lines[4]})
        assert ${#actual4} equals 1
        assert ${actual4[1]} same_as 'containing'

        actual5=(${(0)lines[5]})
        assert ${#actual5} equals 1
        assert ${actual5[1]} same_as 'newlines'
    }

    prefix=
    _fzf_complete_git 'git commit-all '
}

@test 'Testing completion (recursive alias)' {
    run git config alias.foo bar
    run git config alias.bar 'commit --squash'

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git foo '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git 'git foo '
}

@test 'Testing completion (looped alias)' {
    run git config alias.foo bar
    run git config alias.bar baz
    run git config alias.baz foo

    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git foo '
    }

    prefix=
    _fzf_complete_git 'git foo '
}

@test 'Testing completion (alias and expansion)' {
    run git config alias.squash 'commit --squash'

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as '"git"  "squash" '

        run cat
        assert ${#lines} equals 5
        assert ${lines[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${lines[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${lines[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${lines[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${lines[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    prefix=
    _fzf_complete_git '"git"  "squash" '
}

@test 'Testing preview: git add **' {
    run git checkout another-branch
    echo >> ' file3 containing space '
    echo >> directory2/$'file4\ncontaining\nnewlines'
    echo >> ' file5 containing space '
    echo >> directory2/$'file6\ncontaining\nnewlines'

    _fzf_complete() {
        fzf_options=$1 run preview ' M  file3 containing space '
        assert $output is_not_empty

        fzf_options=$1 run preview ' M directory1/file2'
        assert $output is_not_empty

        fzf_options=$1 run preview $' M directory2/file4\ncontaining\nnewlines'
        assert $output is_not_empty

        fzf_options=$1 run preview ' M file1'
        assert $output is_not_empty

        fzf_options=$1 run preview '??  file5 containing space '
        assert $output is_not_empty

        fzf_options=$1 run preview $'?? directory2/file6\ncontaining\nnewlines'
        assert $output is_not_empty
    }

    prefix=
    _fzf_complete_git 'git add '
}

@test 'Testing post: git commits' {
    input=(
        'another-branch   2nd commit'
        'master          1st commit'
        'v1              1st commit'
        'v2               2nd commit'
        "$hash_1         1st commit"
    )

    run _fzf_complete_git-commits_post <<< ${(F)input}

    assert $state equals 0
    assert ${#lines} equals 5
    assert ${lines[1]} same_as 'another-branch'
    assert ${lines[2]} same_as 'master'
    assert ${lines[3]} same_as 'v1'
    assert ${lines[4]} same_as 'v2'
    assert ${lines[5]} same_as $hash_1
}

@test 'Testing post: git commit messages containing space' {
    input=(
        "$hash_1  1st commit"
    )

    run _fzf_complete_git-commit-messages_post <<< ${(F)input}

    assert $state equals 0
    assert ${#lines} equals 1
    assert ${lines[1]} same_as "'1st commit'"
}

@test 'Testing post: git commit messages starting with space' {
    input=(
        "$hash_2   2nd commit"
    )

    run _fzf_complete_git-commit-messages_post <<< ${(F)input}

    assert $state equals 0
    assert ${#lines} equals 1
    assert ${lines[1]} same_as "' 2nd commit'"
}

@test 'Testing post: git unstaged files' {
    input=(
        'M  file1'
        'M  directory1/file2'
        'M   file3 containing space '
        $'M  file4\ncontaining\nnewlines'
        '??  file5 containing space '
        $'?? directory2/file6\ncontaining\nnewlines'
    )

    run _fzf_complete_git-unstaged-files_post <<< ${(pj:\0:)input}

    assert $state equals 0
    assert ${#lines} equals 6

    assert ${lines[1]} same_as 'file1'
    assert ${lines[2]} same_as 'directory1/file2'
    assert ${lines[3]} same_as "' file3 containing space '"
    assert ${lines[4]} same_as "\$'file4\\ncontaining\\nnewlines'"
    assert ${lines[5]} same_as "' file5 containing space '"
    assert ${lines[6]} same_as "\$'directory2/file6\\ncontaining\\nnewlines'"
}
