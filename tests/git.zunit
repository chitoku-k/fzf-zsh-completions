#!/usr/bin/env zunit

@setup {
    TEMP=$(mktemp -d)
    pushd $TEMP

    {
        git init

        mkdir directory1
        echo file1 > file1
        echo file2 > directory1/file2

        git add -A
        git commit -m '1st commit'
        git tag v1

        mkdir directory2
        echo ' file3 containing space ' > ' file3 containing space '
        echo $'file4\ncontaining\nnewlines' > directory2/$'file4\ncontaining\nnewlines'

        git checkout -b another-branch

        git add -A
        git commit -m ' 2nd commit'
        git tag v2

        git checkout master

        echo file1 >> file1
        echo file2 >> directory1/file2
    } &> /dev/null

    popd
}

@teardown {
    rm -rf $TEMP
}

@test 'Testing git checkout/log/rebase/reset' {
    load ../src/git.zsh
    pushd $TEMP

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 matches '^git (checkout|log|rebase|reset)'

        hash_1=$(git rev-parse --short v1)

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 5
        assert ${actual[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${actual[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${actual[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${actual[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${actual[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    LBUFFER=(git checkout '**')
    _fzf_complete_git 'git checkout'

    LBUFFER=(git log '**')
    _fzf_complete_git 'git log'

    LBUFFER=(git rebase '**')
    _fzf_complete_git 'git rebase'

    LBUFFER=(git reset '**')
    _fzf_complete_git 'git reset'
}

@test 'Testing git branch/cherry-pick/merge' {
    load ../src/git.zsh
    pushd $TEMP

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index --multi'
        assert $2 matches '^git (branch|cherry-pick|merge)'

        hash_1=$(git rev-parse --short v1)

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 5
        assert ${actual[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${actual[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${actual[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${actual[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${actual[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    LBUFFER=(git branch -D '**')
    _fzf_complete_git 'git branch -D'

    LBUFFER=(git cherry-pick '**')
    _fzf_complete_git 'git cherry-pick'

    LBUFFER=(git merge '**')
    _fzf_complete_git 'git merge'
}

@test 'Testing git commit --fixup=/--reedit-message=/--reuse-message=/--squash=' {
    load ../src/git.zsh
    pushd $TEMP

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit'

        hash_1=$(git rev-parse --short v1)

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 5
        assert ${actual[1]} same_as "$(tput setaf 3)${prefix}another-branch $(tput sgr0)  2nd commit"
        assert ${actual[2]} same_as "$(tput setaf 3)${prefix}master         $(tput sgr0) 1st commit"
        assert ${actual[3]} same_as "$(tput setaf 3)${prefix}v1             $(tput sgr0) 1st commit"
        assert ${actual[4]} same_as "$(tput setaf 3)${prefix}v2             $(tput sgr0)  2nd commit"
        assert ${actual[5]} same_as "$(tput setaf 3)${prefix}$hash_1        $(tput sgr0) 1st commit"
    }

    LBUFFER=(git commit '--fixup=**')
    prefix=--fixup=
    _fzf_complete_git 'git commit'

    LBUFFER=(git commit '--reedit-message=**')
    prefix=--reedit-message=
    _fzf_complete_git 'git commit'

    LBUFFER=(git merge '--reuse-message=**')
    prefix=--reuse-message=
    _fzf_complete_git 'git commit'

    LBUFFER=(git merge '--squash=**')
    prefix=--squash=
    _fzf_complete_git 'git commit'
}

@test 'Testing git commit -C/--fixup/--reedit-message/--reuse-message/--squash' {
    load ../src/git.zsh
    pushd $TEMP

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit'

        hash_1=$(git rev-parse --short v1)

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 5
        assert ${actual[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${actual[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${actual[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${actual[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${actual[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    LBUFFER=(git commit -C '**')
    prefix=-C
    _fzf_complete_git 'git commit'

    LBUFFER=(git commit -qC '**')
    prefix=-qC
    _fzf_complete_git 'git commit'

    LBUFFER=(git commit --fixup '**')
    prefix=--fixup
    _fzf_complete_git 'git commit'

    LBUFFER=(git commit --reedit-message '**')
    prefix=--reedit-message
    _fzf_complete_git 'git commit'

    LBUFFER=(git merge --reuse-message '**')
    prefix=--reuse-message
    _fzf_complete_git 'git commit'

    LBUFFER=(git merge --squash '**')
    prefix=--squash
    _fzf_complete_git 'git commit'
}
