#!/usr/bin/env zunit

@setup {
    load ../src/git.zsh

    TEMP=$(mktemp -d)
    pushd $TEMP

    {
        git init

        mkdir directory1
        echo file1 > file1
        echo file2 > directory1/file2

        git add -A
        git commit -m '1st commit'
        git tag v1

        mkdir directory2
        echo ' file3 containing space ' > ' file3 containing space '
        echo $'file4\ncontaining\nnewlines' > directory2/$'file4\ncontaining\nnewlines'

        git checkout -b another-branch

        git add -A
        git commit -m ' 2nd commit'
        git tag v2

        git checkout master

        echo file1 >> file1
        echo file2 >> directory1/file2
    } &> /dev/null
}

@teardown {
    rm -rf $TEMP
}

@test 'Testing git checkout/log/rebase/reset' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 matches '^git (checkout|log|rebase|reset) '

        hash_1=$(git rev-parse --short v1)

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 5
        assert ${actual[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${actual[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${actual[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${actual[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${actual[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    LBUFFER=(git checkout '**')
    prefix=
    _fzf_complete_git 'git checkout '

    LBUFFER=(git log '**')
    prefix=
    _fzf_complete_git 'git log '

    LBUFFER=(git rebase '**')
    prefix=
    _fzf_complete_git 'git rebase '

    LBUFFER=(git reset '**')
    prefix=
    _fzf_complete_git 'git reset '
}

@test 'Testing git branch/cherry-pick/merge' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index --multi'
        assert $2 matches '^git (branch|cherry-pick|merge) '

        hash_1=$(git rev-parse --short v1)

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 5
        assert ${actual[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${actual[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${actual[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${actual[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${actual[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    LBUFFER=(git branch -D '**')
    prefix=
    _fzf_complete_git 'git branch -D '

    LBUFFER=(git cherry-pick '**')
    prefix=
    _fzf_complete_git 'git cherry-pick '

    LBUFFER=(git merge '**')
    prefix=
    _fzf_complete_git 'git merge '
}

@test 'Testing git commit --fixup=/--reedit-message=/--reuse-message=/--squash=' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit '

        hash_1=$(git rev-parse --short v1)

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 5
        assert ${actual[1]} same_as "$(tput setaf 3)${prefix}another-branch $(tput sgr0)  2nd commit"
        assert ${actual[2]} same_as "$(tput setaf 3)${prefix}master         $(tput sgr0) 1st commit"
        assert ${actual[3]} same_as "$(tput setaf 3)${prefix}v1             $(tput sgr0) 1st commit"
        assert ${actual[4]} same_as "$(tput setaf 3)${prefix}v2             $(tput sgr0)  2nd commit"
        assert ${actual[5]} same_as "$(tput setaf 3)${prefix}$hash_1        $(tput sgr0) 1st commit"
    }

    LBUFFER=(git commit '--fixup=**')
    prefix=--fixup=
    _fzf_complete_git 'git commit '

    LBUFFER=(git commit '--reedit-message=**')
    prefix=--reedit-message=
    _fzf_complete_git 'git commit '

    LBUFFER=(git commit '--reuse-message=**')
    prefix=--reuse-message=
    _fzf_complete_git 'git commit '

    LBUFFER=(git commit '--squash=**')
    prefix=--squash=
    _fzf_complete_git 'git commit '
}

@test 'Testing git commit -c/-C/--fixup/--reedit-message/--reuse-message/--squash' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 matches '^git commit (-[^-]*[cC]|--(reuse-message|reedit-message|fixup|squash)) '

        hash_1=$(git rev-parse --short v1)

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 5
        assert ${actual[1]} same_as "$(tput setaf 3)another-branch $(tput sgr0)  2nd commit"
        assert ${actual[2]} same_as "$(tput setaf 3)master         $(tput sgr0) 1st commit"
        assert ${actual[3]} same_as "$(tput setaf 3)v1             $(tput sgr0) 1st commit"
        assert ${actual[4]} same_as "$(tput setaf 3)v2             $(tput sgr0)  2nd commit"
        assert ${actual[5]} same_as "$(tput setaf 3)$hash_1        $(tput sgr0) 1st commit"
    }

    LBUFFER=(git commit -c '**')
    prefix=
    _fzf_complete_git 'git commit -c '

    LBUFFER=(git commit -C '**')
    prefix=
    _fzf_complete_git 'git commit -C '

    LBUFFER=(git commit -qc '**')
    prefix=
    _fzf_complete_git 'git commit -qc '

    LBUFFER=(git commit -qC '**')
    prefix=
    _fzf_complete_git 'git commit -qC '

    LBUFFER=(git commit --fixup '**')
    prefix=
    _fzf_complete_git 'git commit --fixup '

    LBUFFER=(git commit --reedit-message '**')
    prefix=
    _fzf_complete_git 'git commit --reedit-message '

    LBUFFER=(git commit --reuse-message '**')
    prefix=
    _fzf_complete_git 'git commit --reuse-message '

    LBUFFER=(git commit --squash '**')
    prefix=
    _fzf_complete_git 'git commit --squash '
}

@test 'Testing git commit --message=' {
    git checkout another-branch &> /dev/null

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 same_as 'git commit '

        hash_1=$(git rev-parse --short v1)
        hash_2=$(git rev-parse --short v2)

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 2
        assert ${actual[1]} same_as "$(tput setaf 3)$hash_2 $(tput sgr0) ${prefix} 2nd commit"
        assert ${actual[2]} same_as "$(tput setaf 3)$hash_1 $(tput sgr0) ${prefix}1st commit"
    }

    LBUFFER=(git commit '--message=**')
    prefix=--message=
    _fzf_complete_git 'git commit '
}

@test 'Testing git commit -m/--message' {
    git checkout another-branch &> /dev/null

    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as '--ansi --tiebreak=index '
        assert $2 matches '^git commit (-[^-]*m|--message) '

        hash_1=$(git rev-parse --short v1)
        hash_2=$(git rev-parse --short v2)

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 2
        assert ${actual[1]} same_as "$(tput setaf 3)$hash_2 $(tput sgr0)  2nd commit"
        assert ${actual[2]} same_as "$(tput setaf 3)$hash_1 $(tput sgr0) 1st commit"
    }

    LBUFFER=(git commit -m '**')
    prefix=
    _fzf_complete_git 'git commit -m '

    LBUFFER=(git commit --message '**')
    prefix=
    _fzf_complete_git 'git commit --message '
}

@test 'Testing git commit --author=/--date=/--author/--date' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    LBUFFER=(git commit '--author=**')
    prefix=--author=
    _fzf_complete_git 'git commit '

    LBUFFER=(git commit '--date=**')
    prefix=--date=
    _fzf_complete_git 'git commit '

    LBUFFER=(git commit --author '**')
    prefix=
    _fzf_complete_git 'git commit --author '

    LBUFFER=(git commit --date '**')
    prefix=
    _fzf_complete_git 'git commit --date '

    assert $? equals 0
}

@test 'Testing git commit --file=/--template=' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 matches '^git commit --(file|template)=$'
    }

    LBUFFER=(git commit '--file=**')
    prefix=--file=
    _fzf_complete_git 'git commit '

    LBUFFER=(git commit '--template=**')
    prefix=--template=
    _fzf_complete_git 'git commit '
}

@test 'Testing git commit -F/-t/--file/--template' {
    _fzf_complete() {
        fail '_fzf_complete should not be invoked'
    }

    _fzf_path_completion() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 matches '^git commit (-[^-]*[Ft]|--(file|template)) '
    }

    LBUFFER=(git commit -F '**')
    prefix=
    _fzf_complete_git 'git commit -F '

    LBUFFER=(git commit -t '**')
    prefix=
    _fzf_complete_git 'git commit -t '

    LBUFFER=(git commit -qF '**')
    prefix=
    _fzf_complete_git 'git commit -qF '

    LBUFFER=(git commit -qt '**')
    prefix=
    _fzf_complete_git 'git commit -qt '

    LBUFFER=(git commit --file '**')
    prefix=
    _fzf_complete_git 'git commit --file '

    LBUFFER=(git commit --template '**')
    prefix=
    _fzf_complete_git 'git commit --template '
}

@test 'Testing git commit --cleanup=' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit '

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 5
        assert ${actual[1]} same_as --cleanup=strip
        assert ${actual[2]} same_as --cleanup=whitespace
        assert ${actual[3]} same_as --cleanup=verbatim
        assert ${actual[4]} same_as --cleanup=scissors
        assert ${actual[5]} same_as --cleanup=default
    }

    LBUFFER=(git commit '--cleanup=**')
    prefix=--cleanup=
    _fzf_complete_git 'git commit '
}

@test 'Testing git commit --cleanup' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit --cleanup '

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 5
        assert ${actual[1]} same_as strip
        assert ${actual[2]} same_as whitespace
        assert ${actual[3]} same_as verbatim
        assert ${actual[4]} same_as scissors
        assert ${actual[5]} same_as default
    }

    LBUFFER=(git commit --cleanup '**')
    prefix=
    _fzf_complete_git 'git commit --cleanup '
}

@test 'Testing git commit --untracked-files=' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit '

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 3
        assert ${actual[1]} same_as --untracked-files=no
        assert ${actual[2]} same_as --untracked-files=normal
        assert ${actual[3]} same_as --untracked-files=all
    }

    LBUFFER=(git commit '--untracked-files=**')
    prefix=--untracked-files=
    _fzf_complete_git 'git commit '
}

@test 'Testing git commit --untracked-files' {
    _fzf_complete() {
        assert $# equals 2
        assert $1 same_as ''
        assert $2 same_as 'git commit --untracked-files '

        input=$(cat)
        actual=(${(f)input})

        assert ${#actual} equals 3
        assert ${actual[1]} same_as no
        assert ${actual[2]} same_as normal
        assert ${actual[3]} same_as all
    }

    LBUFFER=(git commit --untracked-files '**')
    prefix=
    _fzf_complete_git 'git commit --untracked-files '
}
